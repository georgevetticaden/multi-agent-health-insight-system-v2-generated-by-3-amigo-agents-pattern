"""
FastAPI routes for trace management and viewing.

Provides REST API endpoints for retrieving, listing, and viewing traces
generated by the multi-agent health system and evaluation framework.
"""

import os
import json
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import HTMLResponse, FileResponse

# Import tracing components
try:
    from services.tracing import get_trace_collector, TraceEventType, TRACE_STORAGE_PATH
    from services.tracing.html_generator import generate_trace_viewer_html
    TRACING_AVAILABLE = True
except ImportError:
    TRACING_AVAILABLE = False
    TRACE_STORAGE_PATH = "./traces"

router = APIRouter(prefix="/api/traces", tags=["tracing"])


@router.get("/")
async def list_traces(
    source: Optional[str] = Query(None, description="Filter by source (evaluation, production)"),
    user_id: Optional[str] = Query(None, description="Filter by user ID"),
    test_case_id: Optional[str] = Query(None, description="Filter by test case ID"),
    limit: int = Query(50, description="Maximum number of traces to return"),
    offset: int = Query(0, description="Number of traces to skip")
) -> Dict[str, Any]:
    """
    List available traces with optional filters.
    
    Returns:
        Dictionary containing list of trace metadata
    """
    if not TRACING_AVAILABLE:
        raise HTTPException(status_code=503, detail="Tracing not available")
    
    trace_collector = get_trace_collector()
    
    filters = {}
    if source:
        filters["source"] = source
    if user_id:
        filters["user_id"] = user_id
    if test_case_id:
        filters["test_case_id"] = test_case_id
    
    traces = await trace_collector.list_traces(filters, limit, offset)
    
    return {
        "traces": traces,
        "total": len(traces),
        "filters": filters,
        "pagination": {
            "limit": limit,
            "offset": offset
        }
    }


@router.get("/{trace_id}")
async def get_trace(trace_id: str) -> Dict[str, Any]:
    """
    Get a specific trace by ID.
    
    Args:
        trace_id: Unique trace identifier
        
    Returns:
        Complete trace data including all events
    """
    if not TRACING_AVAILABLE:
        raise HTTPException(status_code=503, detail="Tracing not available")
    
    trace_collector = get_trace_collector()
    
    # Try to get from active traces first
    trace = await trace_collector.get_active_trace(trace_id)
    
    # If not active, try stored traces
    if not trace:
        trace = await trace_collector.get_stored_trace(trace_id)
    
    if not trace:
        raise HTTPException(status_code=404, detail=f"Trace {trace_id} not found")
    
    # Convert to dictionary for JSON serialization
    return {
        "trace_id": trace.trace_id,
        "source": trace.source,
        "start_time": trace.start_time,
        "end_time": trace.end_time,
        "total_duration_ms": trace.total_duration_ms,
        "initial_input": trace.initial_input,
        "user_id": trace.user_id,
        "test_case_id": trace.test_case_id,
        "session_id": trace.session_id,
        "events": [
            {
                "event_id": event.event_id,
                "timestamp": event.timestamp,
                "event_type": event.event_type.value,
                "agent_type": event.agent_type,
                "stage": event.stage,
                "data": event.data,
                "duration_ms": event.duration_ms,
                "tokens_used": event.tokens_used,
                "parent_event_id": event.parent_event_id,
                "metadata": event.metadata
            }
            for event in trace.events
        ],
        "summary": trace.summary,
        "metadata": trace.metadata
    }


@router.get("/{trace_id}/viewer")
async def trace_viewer(trace_id: str) -> HTMLResponse:
    """
    Get HTML viewer for a specific trace.
    
    Args:
        trace_id: Unique trace identifier
        
    Returns:
        HTML page for viewing the trace
    """
    if not TRACING_AVAILABLE:
        return HTMLResponse(
            content="<html><body><h1>Tracing Not Available</h1><p>Tracing functionality is not enabled.</p></body></html>",
            status_code=503
        )
    
    # First, try to find pre-generated HTML file
    trace_storage_path = Path(os.environ.get("TRACE_STORAGE_PATH", TRACE_STORAGE_PATH))
    
    # Search for HTML file in date directories
    for date_dir in trace_storage_path.iterdir():
        if date_dir.is_dir() and date_dir.name.count('-') == 2:  # YYYY-MM-DD format
            html_path = date_dir / f"{trace_id}.html"
            if html_path.exists():
                # Serve the pre-generated HTML file
                return FileResponse(
                    path=str(html_path),
                    media_type="text/html",
                    headers={"Cache-Control": "max-age=3600"}  # Cache for 1 hour
                )
    
    # Fall back to dynamic generation if HTML not found
    trace_collector = get_trace_collector()
    
    # Try to get the trace
    trace = await trace_collector.get_active_trace(trace_id)
    if not trace:
        trace = await trace_collector.get_stored_trace(trace_id)
    
    if not trace:
        return HTMLResponse(
            content=f"<html><body><h1>Trace Not Found</h1><p>Trace {trace_id} not found.</p></body></html>",
            status_code=404
        )
    
    # Generate HTML content dynamically
    html_content = generate_trace_viewer_html(trace)
    
    return HTMLResponse(content=html_content)

